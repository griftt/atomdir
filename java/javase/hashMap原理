1.数据结构：采用hash算法，采用链表加数组的方式存储数据，查找，添加等操作很快，仅需一次寻址即可。

2代码结构：
HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。
//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析

 Entry是HashMap中的一个静态内部类。代码如下

```java
static class Entry<K,V> implements Map.Entry<K,V> {
        final K key;
        V value;
        Entry<K,V> next;//存储指向下一个Entry的引用，单链表结构
        int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算

        /**
         * Creates new entry.
         */
        Entry(int h, K k, V v, Entry<K,V> n) {
            value = v;
            next = n;
            key = k;
            hash = h;
        }
```
3 .基本属性：
  (1) 长度默认为16 ，
  (2) 扩容因子为0.75
  (3) 扩容长度必须为2的倍数
    此处原因：因为关系到元素的散列位置，要确保元素要散列在容量的长度之内，通过将散列的值与当前扩容长度（length-1）进行按位与运算，来的容量得出范围内的数组索引位置
    其次为了减少哈希冲突，保证散列均匀。扩容长度为2的倍数后，进行按位计算的数值其实相对之前的长度值的二进制码，只是左边多了一个1而已，散列位置的确认依旧是
    取决于元素的哈希值，（按位与计算时，结果取决于地位的值，），也就是说如果长度的二进制不全为一，那么与运算时就会导致某些位是永远得不到一，也就是某个位置用户不会单散列到
     如图
    ![按位与计算](images/2019/06/按位与计算.png)
  （红黑树的转换时机）
